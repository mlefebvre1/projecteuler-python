from math import sqrt, ceil, gcd
from typing import Iterable, Tuple


def primitive_pythagorean_triples(k: int) -> Iterable[Tuple[int, int, int]]:
    """
    Generate the primitive pythagorean triples up to k (where k is the value of the biggest side)
    :param int k: Limit value value of the biggest side
    :return: A list of primitive pythagorean_triples
    """
    for n in range(1, ceil(sqrt(k))):
        for m in range(n, ceil(sqrt(k))):
            if gcd(n, m) == 1 and m != n and (m + n) % 2:
                a = m * m - n * n
                b = 2 * m * n
                if b < a:
                    a, b = b, a
                c = m * m + n * n
                yield a, b, c


def pythagorean_triples(k: int, stop="hypotenuse") -> Iterable[Tuple[int, int, int]]:
    """
    Generate the pythagorean triples up to when the hypotenuse (hypotenuse) is larger than k (c > k)
                                  or up to when the perimeter (perimeter) is larger than k ( a + b + c < k)

    Euclid's formula is a fundamental formula for generating Pythagorean triples given an arbitrary pair of integers
    m and n with m > n > 0 with
            a = m^2 - n^2,   b = 2*m*n,  c = m^2 + n^2

    The triple generated by Euclid's formula is primitive if and only if m and n are coprime and not both odd. Once
    primitive triples are found, it is easy to generate more using the following formula :
            a = k*(m^2 - n^2),  b = k * (2*m*n),    c = k * (m^2 + n^2)

    """
    primitives = sorted(primitive_pythagorean_triples(k), key=lambda i: i[0])
    for primitive in primitives:
        m = 1
        while 1:
            a, b, c = primitive
            am, bm, cm = a * m, b * m, c * m
            if stop == "hypotenuse":
                if cm > k:
                    break
            else:
                if sum((am, bm, cm)) > k:
                    break
            yield am, bm, cm
            m += 1
